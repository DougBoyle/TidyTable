TODO:
- Reimplement some of the methods currently taken from Chessington
  e.g. Fipping board colour, to no longer involve Square.  
- Allow compressing to stream as well as decompression
- Add a HuffmanStream that decompresses file on the fly/can seek the desired part
- Try different orderings of data (e.g. all DTMs and all Outcomes separate)
  to improve compression efficiency. Also try other compression methods.
- Exploit symmetry for duplicate pieces, already get in board order so N(N-1)/2 cases
- Even denser coding (Eugene Nalimov mentions 7-bits for 5-man positions, see https://www.stmintz.com/ccc/index.php?id=33351),
  much smaller than current 16-bits per position/side.
- Only store half for symmetric tables: KQKQ only needs outcomes for white to move  
- DTM/DTZ should be 0 for drawn positions, regardless of 50-Move rule or stalemate

Descriptions of other techniques:  
- Better compression, try "Limited-Reference" variant of Lempel-Ziv,
  example implementation here: https://github.com/lazydroid/crafty-chess/blob/master/tbdecode.h  
  Also a 7k line .cpp file for endgames: https://github.com/lazydroid/crafty-chess/blob/master/egtb.cpp  
    Note: Encodes indexing of all valid, normalised positions of black/white
  king using just a 64x64 table, up to 462, spanning 250 lines. Does same
  for pawn normalisation (except max is then 1806). Saves about 10%.  
    Up to line 3460 defines computing indexes, lots of work to save a few percent.
  Handles 3-6 pieces and en-passant so can ignore some blocks of code.  
    Lines 3460-3990 describe old (less efficient) indexing method. 
 `IndexNA` refers to indexing method for `N` pieces, `A`/`B` = without/with pawns
    Lines 3990-4470 enumerate all endgames as integer values (i.e. ordering).  
    **Line 4470 starts describing compression**, defines `TB` macro to describe
  various properties, then enumerates those properties for all endgames till line 5000.
  Mostly only relevant to larger boards (KPPKP or 6+ pieces)  
    Line 5350, lots of caching to speed up handling larger tables.  
    `rgpdbDecodeBlocks`/`TbtProbeTable` possibly explain compression
- Discussion of Syzygy tables here: http://kirill-kryukov.com/chess/discussion-board/viewtopic.php?t=6971
  including link to variation of Re-Pair compression algorithm. One benefit of it is that
  it allows changing values within a range at the point of compression (see below).
- Syzygy tables are stm-EGTs (side-to-move) i.e. engine must do a 1 ply search
  to interpret tablebase.
- **Avoid storing move:** Can just store WDL (one table) and DTZ (separate table, 1 sided).
  Since DTM is one-sided, looking up DTM for a position potentially requires probing 1-ply.
  Hence, to get best move in game have to search up to 2-ply, hence *grandfather algorithm*.  
  As long as done carefully, can do the same for DTM. This allows compressing to 1 byte per position, draws always 0.  
  **For DTZ only:** When there is a capture leading to best outcome, can store any value 
  in the DTZ (will get correct value from searching sub-table). Re-Pair allows exploiting this
  to choose values making compression as efficient as possible.

Notes on the algorithm for solving tables:  
Except for the 3-piece tables, we cannot assume that once the outcome of a position
is known then it no longer needs updating. Whereas for 3 pieces the maximum DTM increments
from 0 on each iteration, the DTM values of a 4+ piece table are varied after the first iteration
due to poitions simplifying to sub-table positions with a range of DTM values. For example,
3-ply to a mate in 1 sub-position will be found later than 1-ply to a mate in 5 sub-position.
This affects both wins and the highest DTM of a following position for determining losses,
so both need re-searching until their DTM is less than the number of iterations already performed.

**Size of tables**  
3 Pieces:
  - DTM tables are 616KB total  
  - Uncompressed Move tables are also 616KB
  - Compressed Move tables (needed for game) are 509KB
  - Zipped Move tables are just 116KB
  - Comparison: Just the full KPK table generated by `Chessington.Analysis` was 
      1MB, and all 3 tables totalled 1664KB vs 1125KB here  
      The 3-man Nalimov tables are just 62KB
